package day03.exam;

/*
    클래스 개념익히기
    - 클래스는 객체의 일부이며, 자바에서는 동일하다고 보고있습니다. (엄격히 말씀드리면 객체 > 클래스 입니다.)
    - 즉 모든 클래스는 객체가 됩니다.
    - 클래스란 붕어빵을 만들기 위해 붕어빵틀이 있듯이 이런 틀의 역할을 해주는 자료구조 입니다.
      이 틀을 통해서 객체를 생성하고(인스턴스화), 생성된 객체를 활용하여 프로그래밍을 하게 됩니다.
      즉, 정의해논 자료구조를 생성하여 데이터를 넣고 처리함으로써 프로그램을 완성해 나가게 해주며, 이런 방식을
      객체지향 프로그래밍이라 합니다.

    - 그리고 클래스는 객체간 관계를 맺고, 호출관계나 생성관계의 관점에서 중요하게 보셔야합니다. 관계가 중요해집니다!!

 */

// 하나하나  살펴보도록 하겠습니다

/*
    툴을 통해 클래스를 생성(자바파일 생성)하시면 자동적으로 Test01이라 입력시 -> Test01로 만들어집니다.
    - 여기에서 .java파일명과 만들어진 클래스명이 같아야합니다. 다를경우 에러가 발생합니다.
      그래서 툴이 자동적으로 클래스명==파일명 같게 생성을 해줍니다.
    - class 키워드는 class를 만들겠다는 의미의 예약어(자바시스템에서 미리 설정해놓은 명칭)입니다
    - 클래스 관련해서 이론자료 5장을 한번 읽어주시기 바랍니다.

 */
public class Test01 { // 이름을 .java파일과 다르게 변경해보세요. 에러가 발생합니다.

    /*
        아래처럼 어떤 클래스의 내용(System과 같은)을 클래스 내에 사용시 문법적 에러입니다.
        ex) System.out.println(); 사용시 에러
        -> 이유 : 클래스는 구조(틀)을 정의하는 파일입니다. 즉 자료구조를 사용자정의에 맞게 구성하게 해줍니다. (이론자료 5장 p.5 참조)
                  변수(데이터), 메서드(어떤 행위), 생성자 이 3가지를 정의하는 파일인데,
                  그사이에 다른클래스의 함수 호출이 이루어지기 때문에 문법적 에러가 납니다!!
                  이 구조를 지켜서 클래스를 정의(작성)하셔야 합니다
     */

    //    System.out.println(); // 문법적 에러 : 주석풀어보시면 확인이 가능합니다.

    /*
        1. 멤버 변수 정의 (객체의 데이터 정의)
        접근제한자 (접근지정자)
        - 접근제한이란 외부에서 접근을 허용하는 수준을 말합니다
        - 접근제한자를 통해 데이터의 접근 허용 범위를 지정한다고 보시면 됩니다.
        - 이렇게 하는 이유는 외부에 데이터와 메서드를 제공시 어느정도 수준까지 하기 해야할지 정하기 위함이며
          , 보안적 측면에서 데이터를 다 보여주면 안되기 때문입니다.(캡슐화)
          캡슐화 : 데이터의 의미를 자기자신만 알고 외부에 공개하지 않게해주며, 외부에서 신경써야할 대상을 줄여줍니다.
          캡슐화가 잘되어 있는 클래스들은 재사용시 사용이 편리해집니다.

        - 즉 이렇게 하게되면 해당클래스의 내부정보를 모르고 사용만 하면되기 때문에 사용자 입장을고려합니다
          ex) System.out.println() 같은 경우 println메서드의 구현내용은 모르지만 이게 콘솔출력이기 때문에 사용을 무식적으로하는 것과 같습니다.

            접근제한자 (접근지정자) 종류
            * public    : 모든 내,외부 접근 허용 (공개 수준 : 넓음)
            * prtected  : 동일패키지 + 상속관계의 클래스 끼리만 접근 허용(공개 수준 : 중간)
            * 생략      : 동일패키지 (공개 수준 : 좁음~중간) -> 잘 안쓰임
            * private   : 본인 클래스내에서만 접근 허용 (공개 수준 : 좁음)

            일반지정자 종류
            * static    : 객체생성필요 없이 사용이 가능할때 사용
            * final     : 상수화 -> 이 지정자는 변수, 메서드, 클래스에 다 가능하며 의미는 제각기 차이가 있습니다.
            *             (이론자료 5장 p.26 참조)
            * abstract  : 추상화키워드 4주차에 배울내용이므로 이런게 있다 정도로 넘어가겠습니다. -> 메서드, 클래스에 사용됨

            지정자는 일반지정자 + 접근지정자 혼홥사용이 가능하며 때에 따라 활용을 하실 줄 알아야 합니다.

     */

    // 모든 곳
    public int a;

    // 동일패키지 + 상속관계 + 자기자신
    protected int b;

    // 동일패키지 + 자기자신
    int c;  // -> 잘 쓰이지 않으며, 엄격하게 따지는 자바 성격상. 지정자도 명시를 선호합니다.

    // 자기자신
    private int d;

    /**
     * 이주석은 javadoc 주석이라합니다. (한글깨짐 방지 옵션 -encoding UTF-8 -charset UTF-8 -docencoding UTF-8)
     * 외부에서 접근시 지금의 주석내용을 코멘트로 볼수 있게해줍니다!!
     * 또한 https://docs.oracle.com/javase/7/docs/api/ (ctrl+왼쪽마우스로 이동) 처럼 HTML 문서로 API문서를 만들때 주석 내용을 보여줍니다.
     * <p>
     * 변수 a는 접근제한자 public이며, 일반지정자 static을 사용했으므로
     * 변수a는 클래스간 공유메모리에 올라가 클래스 끼리 동시 접근이 가능합니다!
     * 그래서 클래스변수라 한다.
     * <p>
     * static은 객체 생성 없이 클래스.변수명으로 접근이 바로 가능합니다.
     * - 이유 : static으로 선언하면 JVM이 가동되고 클래스가 로딩되는 시점에 static으로 지정된 모든 변수와 메서드가 클래스영역에 올라가게 됩니다.
     * (이론자료 5장 p.23 참조)
     */

    /*
        혼합사용
        - 혼합되는 그 의미 그대로 해석하실줄 알면 됩니다.
        - 일반지정자 static, final, abstract : 메서드, 클래스에 사용됨 (여기서는 일단 제외)
        - 접근지정자 public, protected, private 생략은 왠만하면 사용을 금합니다.
     */
    // static : 클래스간 공유 -> 클래스변수
    public static int classVariable;        // public static    -> 모든곳에서 접근이 허용되고, 클래스간 공유가 가능

    protected static int classVariable2;    // protected static -> 동일패키지 + 상속 + 자신 접근되고, 클래스간 공유가 가능

    private static int classVariable3;      // private static   -> 자신 접근되고, 클래스간 공유가 가능

    // final변수는 선언과 동시에 무조건 초기화를 해주어야함
    public final int finalValue = 10;           // public final     -> 모든곳 접근, 변경불가
    protected final int finalValue2 = 11;       // protected final  -> 동일패키지 + 상속 + 자신 접근, 변경불가
    private final int finalValue3 = 12;         // private final    -> 자신 접근, 변경불가


    // 접근지정자 + (일반지정자 final + static)
    public final static int staticFinalValue = 10;    // 모든곳 접근, 변경불가 + 클래스공유


    /*
        2. 멤버메서드 정의 (객체의 어떤행위 정의)
        - 메서드(함수)는 간단히 어떤 데이터를 주면 결과값을 받아내기 위한 작업이라 생각하시면 됩니다.
        - 구조 : 인풋(매개변수) -> 아웃풋(리턴값)
            매개변수는 0개 이상이 가능하며,
            반환이 필요한 경우는 return 값; 으로 표현하며
            실행만하고 반환이 필요없는 경우 void 라는 예약어를 명시하고 return을 사용하지않거나 사용하셔도 무방합니다

        - 메서드는 클래스가 어떤 행위를 할 수 있도록 정의를 하는 겁니다.
            ex) System.out.println() : 출
        - 변수명과 동일하게 메서드명도 기본적으로 중복이되면 안됩니다만.. 중복되어도 허용이 되긴합니다 (식별이 가능하다면 허용 -> 오버로딩이라함)
        - 접근지정자, 일반지정자를 명시하여 함께 사용됩니다.

        - 구조형식 -> 지정자 자료형 메서드명(매개변수) {로직구현}  순서입니다   : 이론자료 5장 p.11 참조
     */


    public void methodName(int a, double b, String s) {
        System.out.println("괄호안의 변수 a, b, s를 매개변수라합니다.");
        System.out.println("매개변수란 들어온(인풋) 값을 의미하며 이 데이터를 가지고 아웃풋을 내주면 됩니다.");
        System.out.println("꼭 아웃풋(리턴값)을 안주고 데이터를 활용하여 실행만해도 가능은합니다 그럴경우 void 를 명시하면됩니다.");

        System.out.println("접근지정자가 public 이므로 모든 곳에서 호출 가능 메서드");

        System.out.println("기본적으로 return 되는 값과 메서드 정의시 return 자료형이 맞아야 합니다!");
//        return;       // 주석풀고 확인 : 가능합니다 어떤 값만 반환을 안한다면!
//        return 10;    // 주석풀고 확인 : 하지만 이경우는 에러입니다. void로 명시를 했지만 10이란 값을 반환하고 있기 때문입니다. 어떤 값을 반환해도 에러입니다.
    }

    // int -> double로 변경하고 return되는 값은 int형이면 가능    -> 왜 가능 할까요? 감이오시나요??
    protected int methodName2(int a) {
        int kk = 10;
        System.out.println("접근지정자가 protected 이므로 동일패키지 + 상속관계 + 자신 호출가능 메서드");
        System.out.println("a는 매개변수, kk는 로컬변수");
        System.out.println("kk + a를 리턴합니다. return 예약어가 리턴을 하겠다는 예약어입니다. " +
                "리턴값의 자료형과 메서드에서 메서드 왼쪽에 명시한 자료형이 기본적을 같아야하지만 형변환을 통해 받아들여지기만 한다면 다가능합니다");
        System.out.println("예를들어 methodName2 옆에 int를 double로 바꿔보시면 가능하단걸 이제 이해하실 수 있을겁니다!");

        return kk + a;
    }

    private String methodName3(String s) {
        System.out.println("접근지정자가 private 이므로 자기자신 호출 가능 메서드");
        return "Hello" + s; // Hello에 매개변수 s값이 합쳐져서 리턴됨
    }


    // 변수처럼 메서드도 접근지정자+일반지정자 혼합이 가능할까요??? -> 생각해보신 후 method4 주석을 풀어보시기 바랍니다
//    public static void method4() {
//        System.out.println("네 가능합니다. public static int a 와 같은 변수는 클래스 변수여서 클래스간 공유를 한다고 했습니다. " +
//                "객체 생성없이 변수 사용이 가능했었죠. 사용법은 클래스명.변수명 이였습니다.");
//        System.out.println("그렇다면 메서드는??");
//        System.out.println("메서드도 마찬가지로 static 지정자는 전부 객체생성없이 사용이 가능합니다!!");
//        System.out.println("메서드도 변수처럼 사용법은 클래스명.메서드명이 되며, 클래스간 공유를 하게 됩니다.");
//    }

    // 이아래 overload 메서드는 에러가 날까요?? 주석을 풀고 확인해보시기 바랍니다!
//    public void overload() {
//        System.out.println("이유??");
//    }

    public void overload(int a, int b) {
        System.out.println("여기를 가능하게 바꿔볼까요??");
        System.out.println("매개변수를 추가하거나 같은위치의 자료형을 바꿔주면 호출시점에서 다르게 인식하고 호출이 가능하게되므로" +
                "동일한 메서드명으로 같은내용을 담을때 활용됩니다.");
        System.out.println("예가 지금 println 메서드 입니다. println은 매개변수로 문자, 숫자 등등 데이터를 넣어도 동일하게 출력이 가능합니다.");
    }


    public void overload(int a, String s) {

    }


}
