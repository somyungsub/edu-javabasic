
/*
    package 문
    - 이론자료 5장 p.22 참조
    - 패키지는 간단히 지금 현재 파일의 위치가 속해있는 위치를 명시해주며, 디렉토리(폴더) 구조라고 보시면 이해가 빠르실 겁니다.
    - 파일의 위치를 통해 다른 클래스의 라이브러리를 호출 할 때 이름의 충돌을 회피할 수 있게 해줍니다.
      ex) 한 폴더안에 같은 파일명이 있으면?? 보통 덮어쓰기가 발생하죠? 같은 원리라고 생각하시면 됩니다.
          기본적으로 모든 파일명은 중복이 되면 안되기 때문에 자바또한 이런 패키지구조(폴더구조)를 통해 구분을 해주고,
          동일 파일명이 있어도 패키지 경로가 다르면 다른파일로 인식하게 해주는 역할을 합니다.
    - src밑에는 package문이 사용될 필요는 없습니다만 패키지를 생성하여 관리할 경우 package문을 명시해주셔야 합니다.
 */

package day03.exam.basic;


/*
    import 패키지명
     - 이론자료 5장 p.21 참조
     - import는 다른파일의 위치(패키지)를 명시하여 그 위치의 자바파일을 사용하기 위함입니다
     - import를 통해 다른 자바파일을 재사용하며 프로그래밍을 가능하게 해줍니다.
     - import 문의 위치는 클래스명
 */


/*
    클래스 개념익히기
    - 클래스는 객체의 일부이며, 자바에서는 동일하다고 보고있습니다. (엄격히 말씀드리면 객체 > 클래스 입니다.)
    - 즉 모든 클래스는 객체가 됩니다.
    - 클래스란 붕어빵을 만들기 위해 붕어빵틀이 있듯이 이런 틀의 역할을 해주는 자료구조 입니다.
      이 틀을 통해서 객체를 생성하고(인스턴스화), 생성된 객체를 활용하여 프로그래밍을 하게 됩니다.
      즉, 정의해논 자료구조를 생성하여 데이터를 넣고 처리함으로써 프로그램을 완성해 나가게 해주며, 이런 방식을
      객체지향 프로그래밍이라 합니다.

    - 그리고 클래스는 객체간 관계를 맺고, 호출관계나 생성관계의 관점에서 중요하게 보셔야합니다. 관계가 중요해집니다!!

 */

// 하나하나  살펴보도록 하겠습니다

/*
    툴을 통해 클래스를 생성(자바파일 생성)하시면 자동적으로 Test01이라 입력시 -> Test01로 만들어집니다.
    - 여기에서 .java파일명과 만들어진 클래스명이 같아야합니다. 다를경우 에러가 발생합니다.
      그래서 툴이 자동적으로 클래스명==파일명 같게 생성을 해줍니다.
    - class 키워드는 class를 만들겠다는 의미의 예약어(자바시스템에서 미리 설정해놓은 명칭)입니다
    - 클래스 관련해서 이론자료 5장을 한번 읽어주시기 바랍니다.

 */
public class Test01 { // 이름을 .java파일과 다르게 변경해보세요. 에러가 발생합니다.

    /*
        아래처럼 어떤 클래스의 내용(System과 같은)을 클래스 내에 사용시 문법적 에러입니다.
        ex) System.out.println(); 사용시 에러
        -> 이유 : 클래스는 구조(틀)을 정의하는 파일입니다. 즉 자료구조를 사용자정의에 맞게 구성하게 해줍니다. (이론자료 5장 p.5 참조)
                  변수(데이터), 메서드(어떤 행위), 생성자 이 3가지를 정의하는 파일인데,
                  그사이에 다른클래스의 함수 호출이 이루어지기 때문에 문법적 에러가 납니다!!
                  이 구조를 지켜서 클래스를 정의(작성)하셔야 합니다
     */

    //    System.out.println(); // 문법적 에러 : 주석풀어보시면 확인이 가능합니다.

    /*
        1. 멤버 변수 정의 (객체의 데이터 정의)
        접근제한자 (접근지정자)
        - 접근제한이란 외부에서 접근을 허용하는 수준을 말합니다
        - 접근제한자를 통해 데이터의 접근 허용 범위를 지정한다고 보시면 됩니다.
        - 이렇게 하는 이유는 외부에 데이터와 메서드를 제공시 어느정도 수준까지 공개(접근허용) 해야할지 정하기 위함이며
          , 보안적 측면에서 데이터를 다 보여주면 안되기 때문입니다.(캡슐화)
          캡슐화 : 데이터의 의미를 자기자신만 알고 외부에 공개하지 않게해주며, 외부에서 신경써야할 대상을 줄여줍니다.
          캡슐화가 잘되어 있는 클래스들은 재사용시 사용이 편리해집니다.
          => 사용자가 제공 클래스 내용을 전부 공개한다면?? 알아야할 내용(분석시간)도 많아지고, 어떤 로직처리를 위한 메서드인지 사용해야할 메서드인지
             분간이 안가게 되니다. 따라서 적절한 캡슐화가 필요합니다.

        - 즉 이렇게 하게되면 해당클래스의 내부정보를 모르고 사용만 하면되기 때문에 사용자 입장을고려합니다
          ex) System.out.println() 같은 경우 println메서드의 구현내용은 모르지만 이게 콘솔출력이기 때문에 사용을 무식적으로하는 것과 같습니다.

            접근제한자 (접근지정자) 종류
            * public    : 모든 내,외부 접근 허용 (공개 수준 : 넓음)
            * prtected  : 동일패키지 + 상속관계 + 자기자신 접근 허용(공개 수준 : 중간)
            * 생략      : 동일패키지 (공개 수준 : 좁음~중간) -> 잘 안쓰임 ( 접근지정자는  무조건 명시해서 사용하시는게 좋고, 그렇게하셔야합니다)
            * private   : 본인 클래스내에서만(자기자신) 접근 허용 (공개 수준 : 좁음)

            일반지정자 종류
            * static    : 객체생성필요 없이 사용이 가능할때 사용
            * final     : 상수화 -> 이 지정자는 변수, 메서드, 클래스에 다 가능하며 의미는 제각기 차이가 있습니다.
            *             (이론자료 5장 p.26 참조)
            * abstract  : 추상화키워드 4주차에 배울내용이므로 이런게 있다 정도로 넘어가겠습니다. -> 메서드, 클래스에 사용됨

            지정자는 일반지정자 + 접근지정자 혼홥사용이 가능하며 때에 따라 활용을 하실 줄 알아야 합니다.
            또한 이런 키워드를 통해 의미를 해석하고 코드를 읽으실 줄 아셔야합니다.

     */

    // 모든 곳
    public static int a;
    public int a2;

    // 동일패키지 + 상속관계 + 자기자신
    protected int b;

    // 동일패키지 + 자기자신
    int c;  // -> 잘 쓰이지 않으며, 엄격하게 따지는 자바 성격상. 지정자도 명시를 선호합니다.

    // 자기자신 (내부에서만 사용되는 데이터)
    private int d;
    private String name;

    /**
     * 이주석은 javadoc 주석이라합니다. (한글깨짐 방지 옵션 -encoding UTF-8 -charset UTF-8 -docencoding UTF-8)
     * 외부에서 접근시 지금의 주석내용을 코멘트로 볼수 있게해줍니다!!
     * 또한 https://docs.oracle.com/javase/7/docs/api/ (ctrl+왼쪽마우스로 이동) 처럼 HTML 문서로 API문서를 만들때 주석 내용을 보여줍니다.
     * <p>
     * 변수 a는 접근제한자 public이며, 일반지정자 static을 사용했으므로
     * 변수a는 클래스간 공유메모리에 올라가 클래스 끼리 동시 접근이 가능합니다!
     * 그래서 클래스변수라 한다.
     * <p>
     * static은 객체 생성 없이 클래스.변수명으로 접근이 바로 가능합니다.
     * - 이유 : static으로 선언하면 JVM이 가동되고 클래스가 로딩되는 시점에 static으로 지정된 모든 변수와 메서드가 클래스영역에 올라가게 됩니다.
     * (이론자료 5장 p.23 참조)
     */

    /*
        혼합사용
        - 혼합되는 그 의미 그대로 해석하실줄 알면 됩니다.
        - 일반지정자 static, final, abstract(메서드, 클래스에 사용됨, 여기서는 일단 제외)
        - 접근지정자 public, protected, private, 생략은 왠만하면 사용을 금합니다.
     */
    // static : 클래스간 공유 -> 클래스변수
    public static int classVariable;        // public static    -> 모든곳에서 접근이 허용되고, 클래스간 공유가 가능

    protected static int classVariable2;    // protected static -> 동일패키지 + 상속 + 자신 접근되고, 클래스간 공유가 가능

    private static int classVariable3;      // private static   -> 자신 접근되고, 클래스간 공유가 가능

    // final변수는 선언과 동시에 무조건 초기화를 해주어야함
    public final int finalValue = 10;           // public final     -> 모든곳 접근, 변경불가
    protected final int finalValue2 = 11;       // protected final  -> 동일패키지 + 상속 + 자신 접근, 변경불가
    private final int finalValue3 = 12;         // private final    -> 자신 접근, 변경불가


    // 접근지정자 + (일반지정자 final + static)
    public final static int staticFinalValue = 10;    // 모든곳 접근, 변경불가 + 클래스공유
    protected final static int staticFinalValue2 = 10;    // 동일패키지 + 상속관계 + 자기자신 접근, 변경불가 + 클래스공유


    /*
        2. 멤버메서드 정의 (객체의 어떤행위 정의)
        - 메서드(함수)는 간단히 어떤 데이터를 주면 결과값을 받아내기 위한 작업이라 생각하시면 됩니다.
        - 구조형식 -> 지정자 자료형 메서드명(매개변수) {로직구현}  순서입니다   : 이론자료 5장 p.11 참조
        - 구조 : 인풋(매개변수) -> 아웃풋(리턴값)
            매개변수 : 매개변수는 0개 이상이 가능하며,
            리턴 :  반환이 필요한 경우는 return 값; 으로 표현하며
                    실행만하고 반환이 필요없는 경우 자료형(int, double...) 대신 void 라는 예약어를 명시하고
                    void경우 return을 사용하지않거나 사용하셔도 무방하나 사용시 return ; 이라 해주어야 가능

        - 메서드는 클래스가 어떤 행위를 할 수 있도록 정의를 하는 겁니다.
            ex) System.out.println(데이터) : 데이터 출력
        - 변수명과 동일하게 메서드명도 기본적으로 중복이되면 안됩니다만.. 중복되어도 허용이 되긴합니다 (식별이 가능하다면 허용 -> 오버로딩이라함)
        - 접근지정자, 일반지정자를 명시하여 함께 사용됩니다.
     */


    public void methodName(int a, double b, String s, int[] arr) {
        System.out.println("괄호안의 변수 a, b, s, arr를 매개변수라하며 그 앞 int, double, String, int[]은 자료형에 해당합니다.");

        // 중요 꼭 숙지!! 매개변수의 특성   -> Test02와 Main2 에서 조금 더 집중적으로 다룹니다!.
        System.out.println("이처럼 매개변수의 타입은 기본타입과 참조타입 전부 받을 수 있으며 " +
                "int, double 같은 기본타입은 데이터의 값을 전달하며 전달되어 들어온 데이터를 활용하면 됩니다." +
                "하지만 String, int[](배열)과 같은 객체로 매개변수를 받을때는 주소값을 전달받게 되며 이주소에 접근하여 " +
                "저장되어 있는 각종 정보에 접근이 가능해집니다. 접근이 가능하다는 것은 거기에 저장된 데이터를 활용하거나 데이터 정보 변경이 가능할 수 있음을 의미합니다.");

        System.out.println("이런 매개변수를 통해 들어온(인풋) 값으로 어떤 로직처리 작업을 하고 난 후 아웃풋을 내주면 됩니다.");
        System.out.println("반환 할 때는 return 예약어를 써야합니다. return 을 만나는순간 메서드는 값을 반환하고 메서드를 그 위치에서 종료하게 됩니다.");
        System.out.println("꼭 아웃풋(리턴값)을 안주고 데이터를 활용하여 실행만해도 가능은합니다 ");
        System.out.println("그럴경우 메서드 정의시 리턴 타입(자료형)에 void 를 명시하면됩니다.");
        System.out.println("이 메서드는 접근지정자가 public 이므로 모든 곳에서 호출 가능한 메서드!!");
        System.out.println("기본적으로 return 되는 값과 메서드 정의시 return 자료형이 맞아야 합니다!");

//        return;       // 주석풀고 확인 : 가능합니다 어떤 값만 반환을 안한다면!
//        return 10;    // 주석풀고 확인 : 하지만 이경우는 에러입니다. void로 명시를 했지만 10이란 값을 반환하고 있기 때문입니다. 어떤 값을 반환해도 에러입니다.
    }

    // 리턴타입을 int -> double로 변경하고 return되는 값은 int형이면 가능    -> 왜 가능 할까요? 감이오시나요?? 형변환 때문입니다!
    protected int methodName2(int a) {
        int kk = 10;    // 이 메서드 안에서만 활용되는 변수입니다 -> 이런변수를 로컬변수라하며 이메서드 안에서만 활용되고 사라지게 됩니다. 저장메모리영역은 stack영역입니다. 기억이 안나시면 1주차 참조!

        System.out.println("접근지정자가 protected 이므로 동일패키지 + 상속관계 + 자신 호출가능 메서드");
        System.out.println("a는 매개변수, kk는 로컬변수");
        System.out.println("kk + a를 리턴합니다. " +
                "리턴값의 자료형과 메서드에서 메서드 왼쪽에 명시한 자료형이 기본적으로 같아야하지만 형변환을 통해 받아들여지기만 한다면 다가능합니다");
        System.out.println("예를들어 methodName2 옆에 int를 double로 바꿔보시면 가능하단걸 이제 이해하실 수 있을겁니다!");

        return kk + a;  // kk + a 값을 반환 반환시 기본타입이므로 정수형 데이터를 반환하게 됩니다!
    }

    private String methodName3(String s) {
        System.out.println("접근지정자가 private 이므로 자기자신 호출 가능 메서드");
        return "Hello" + s; // Hello에 매개변수 s값이 합쳐져서 리턴됨 -> 이경우는 객체를 반환하기 때문에 주소값 리턴
    }


    // 변수처럼 메서드도 접근지정자+일반지정자 혼합이 가능할까요??? -> 생각해보신 후 method4 주석을 풀어보시기 바랍니다

    public static void method4() {
        System.out.println("네 가능합니다. public static int a 와 같은 변수는 클래스 변수여서 클래스간 공유를 한다고 했습니다. " +
                "객체 생성없이 변수 사용이 가능했었죠. 사용법은 클래스명.변수명 이였습니다.");
        System.out.println("그렇다면 메서드는??");
        System.out.println("메서드도 마찬가지로 static 지정자는 전부 객체생성없이 사용이 가능합니다!!");
        System.out.println("메서드도 변수처럼 사용법은 클래스명.메서드명이 되며, 클래스간 공유를 하게 됩니다.");
    }



    // 아래 overLoadMethod 메서드는 에러가 날까요?? 주석을 풀고 확인해보시기 바랍니다!

//    public void overLoadMethod() {
//        System.out.println("오버로딩1");
//    }
//
//    public void overLoadMethod(int a, int b) {
//        System.out.println("오버로딩2 a + b ->" + (a + b));
//        System.out.println("여기를 가능하게 바꿔볼까요??");
//        System.out.println("매개변수를 추가하거나 같은위치의 자료형을 바꿔주면 호출시점에서 다르게 인식하고 호출이 가능하게되므로" +
//                "동일한 메서드명으로 같은내용을 담을때 활용됩니다.");
//        System.out.println("예가 출력시 자주 사용하던 println 메서드 입니다. println은 매개변수로 문자, 숫자 등등 데이터를 넣어도 동일하게 출력이 가능합니다.");
//    }
//
//    public void overLoadMethod(int a, String s) {
//        System.out.println("오버로딩3 a + s ->" + (a + s));
//        System.out.println("갯수는 같지만 2번째 자료형이 다르므로, 호출시 다르게 인식이되어 구분이 가능합니다.");
//    }


    // 오버로딩 : 실무에서 자주 쓰이는 기법중 한 예입니다.
    public int plus(int a, int b) {
        return a + b;
    }

    public int plus(int a, int b, int c) {
        return plus(a, b) + c;
    }

    public int plus(int a, int b, int c, int d) {
        return plus(a, b, c) + d;
    }

    // 하지만 위 같은 형식은 매개변수를 배열로 받을 수 있으므로  해당 메서드로 표현이 다 가능하겠죠?? 위 예시는 오버로딩 개념을 익히기 위한 예시로 보시면 됩니다.
    public int plus(int[] arr) {
        int sum = 0;

        // 반복문 때 잠깐 소개 해드린 foreach 문입니다. 순차 탐색을 하여 데이터를 활용해야하는 경우 사용을 하시면 됩니다!
        for (int i : arr) {
            sum += i;
        }

        /// 위 foreach 문과 동일한 내용의 for문입니다! 기억이 안나신다면 여기에서 다시한번 숙지해보시기 바랍니다!!
//        for (int i = 0; i < arr.length; i++) {
//            sum += arr[i];
//        }

        return sum;
    }


    /*
        3. 생성자 (이론자료 5장 p.14~15 참조)
        - 생성자란 객체 생성시 호출되는 특별한 메서드라고 보시면 됩니다.
        - 메서드와 같은 형식을 취하지만, 리턴이 없으며, 이름은 클래스명과 같아야 합니다.

        * 리턴타입 예를 들면 int나 double 등등의 자료형을 명시하면 생성자가 아닌 메서드가 되므로 주의하셔야합니다!!
     */

    /*
        기본생성자 - 디폴트생성자라고도 함.
        - 매개변수가 없는 생성자
        - 기본생성자 외는 그냥 생성자라고 합니다.
        - 생성자를 작성하지 않을 경우 내부적으로 자동생성된다해서 디폴트or기본생성자라 부릅니다.
     */
    public Test01() {
        System.out.println("new연산자를 통해 Test01의 객체를 생성시에 호출되는 특별한 메서드! -> 생성자");
        System.out.println("지금처럼 매개변수가 없는 경우를 기본 or 디폴트생성자라 합니다.");
        System.out.println("객체 생성과 동시에 호출되므로 보통은 멤버변수의 초기화작업 및 생성과동시에 해야할 작업들을 명시합니다.");
    }

    /*
        생성자
        - 생성자도 오버로딩이 가능합니다.
        - 하는 방법은 생성자도 메서드 이므로 메서드와 동일한 방식을 취합니다
          즉, 매개변수를 통해 오버로딩을 할 수있고, 형식에 맞게 각각 다른 생성자를 호출 할 수 있습니다!!
     */
    public Test01(int a){
        System.out.println("매개변수 1개 ");
        System.out.println("아래 this 키워드는 지금 현재 작업되고 있는 파일의 객체를 가르킵니다");
        System.out.println("즉 현재 Test01 파일에서 작업을 하고 있으므로 this는 Test01을 가르킵니다.");

        // 데이터 초기화 작업
        this.a = a;     // this.a는 Test01의 a 변수를 가르킵니다. 즉 this.a에 매개변수 a의 데이터를 넣습니다.
//        a = a;  // 이것은 어떤 의미일까요????   -> 변수의 우선순위 접근 예상해보기    우선순위는 현재 메서드영역을 찾아서 있으면 쓰고, 없으면 전역(클래스내부)까지 올라가서 찾게 됩니다.
    }

    public Test01(int a, int b) {
        System.out.println("매개변수 2개");
        System.out.println("지금처럼 멤버변수(클래스안의 정의된변수)를 초기화하는데 활용되며, 객체생성시 매개변수로 전달된 데이터를 가지고 처리합니다");
        this.a = a;
        this.b = b;
    }

    public Test01(int a, int b, String name) {
        this(a,b);  // 생각해보기 -> 얘가 가르키는 곳은 ??
        this.name = name;
        System.out.println("매개변수 3개");  // this(a,b)보다 위에 있으면 에러가 납니다!
        System.out.println("this()는 자신을 호출하는 메서드 -> 즉 생성자를 가르키게 됩니다. 여기서 중요한 점은 생성자는 항상 위에 존재해야하는 제약이 생깁니다.");
        System.out.println("name : " + name);
    }

}
